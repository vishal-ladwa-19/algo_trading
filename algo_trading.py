# -*- coding: utf-8 -*-
"""algo trading.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GD0p8mkwsiVDtlJb6WAelB1Am4ycgpyR
"""

!pip install yfinance pandas numpy ta matplotlib

from google.colab import drive
drive.mount('/content/drive')

# Create a folder for outputs
import os
output_dir = "/content/drive/MyDrive/AlgoTrading"
os.makedirs(output_dir, exist_ok=True)

import yfinance as yf
import pandas as pd
import numpy as np
import ta
import matplotlib.pyplot as plt
import logging

# ---------------------------
# Config
# ---------------------------
TICKERS = ["TCS.NS", "INFY.NS", "RELIANCE.NS"]   # change if needed
PERIOD = "6mo"
INTERVAL = "1d"
RSI_WINDOW = 14
SMA_SHORT = 20
SMA_LONG = 50
RESULTS_CSV = f"{output_dir}/Backtest_Results.csv"

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# ---------------------------
# Functions
# ---------------------------
def fetch_data(ticker: str) -> pd.DataFrame:
    df = yf.download(ticker, period=PERIOD, interval=INTERVAL, auto_adjust=True, progress=False)
    if df.empty:
        raise ValueError(f"No data for {ticker}")
    df.index = pd.to_datetime(df.index)
    return df

def add_indicators(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()

    # Flatten if yfinance returns multi-index columns
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = [col[0] if isinstance(col, tuple) else col for col in df.columns]

    # Force all columns to be Series, not DataFrames
    for col in ['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']:
        if col in df.columns:
            df[col] = df[col].astype(float).squeeze()

    # RSI (14)
    df['RSI_14'] = ta.momentum.RSIIndicator(
        close=df['Close'],
        window=RSI_WINDOW
    ).rsi()

    # SMA 20 & 50
    df[f'SMA_{SMA_SHORT}'] = df['Close'].rolling(SMA_SHORT).mean()
    df[f'SMA_{SMA_LONG}'] = df['Close'].rolling(SMA_LONG).mean()

    # Cross detection
    short_col, long_col = f'SMA_{SMA_SHORT}', f'SMA_{SMA_LONG}'
    df['short_gt_long'] = df[short_col] > df[long_col]
    df['short_gt_long_prev'] = df['short_gt_long'].shift(1).fillna(False)
    df['cross_up'] = df['short_gt_long'] & (~df['short_gt_long_prev'])
    df['cross_down'] = (~df['short_gt_long']) & (df['short_gt_long_prev'])

    return df



def backtest_df(df: pd.DataFrame, ticker: str):
    trades = []
    position = False
    entry_price, entry_date = None, None
    df['Buy_Signal'] = (df['RSI_14'] < 30) & (df['cross_up'])
    for i in range(len(df) - 1):
        row, next_row = df.iloc[i], df.iloc[i+1]
        if not position and row['Buy_Signal']:
            if not np.isnan(next_row['Open']):
                position = True
                entry_price = float(next_row['Open'])
                entry_date = df.index[i+1]
        elif position:
            if (row['RSI_14'] > 60) or row['cross_down']:
                exit_price = float(next_row['Open']) if not np.isnan(next_row['Open']) else float(row['Close'])
                exit_date = df.index[i+1]
                pnl_pct = ((exit_price - entry_price) / entry_price) * 100
                trades.append({
                    'Ticker': ticker,
                    'Entry_Date': entry_date.date().isoformat(),
                    'Entry_Price': round(entry_price, 2),
                    'Exit_Date': exit_date.date().isoformat(),
                    'Exit_Price': round(exit_price, 2),
                    'PnL_%': round(pnl_pct, 2)
                })
                position = False
                entry_price, entry_date = None, None
    if position:
        last_close = float(df.iloc[-1]['Close'])
        pnl_pct = ((last_close - entry_price) / entry_price) * 100
        trades.append({
            'Ticker': ticker,
            'Entry_Date': entry_date.date().isoformat(),
            'Entry_Price': round(entry_price, 2),
            'Exit_Date': df.index[-1].date().isoformat(),
            'Exit_Price': round(last_close, 2),
            'PnL_%': round(pnl_pct, 2)
        })
    return trades

def summarize_trades(trades_df: pd.DataFrame):
    if trades_df.empty:
        return {'Trades': 0, 'Win%': 0, 'Total_PnL%': 0}
    win_rate = (trades_df['PnL_%'] > 0).mean() * 100
    return {
        'Trades': len(trades_df),
        'Win%': round(win_rate, 2),
        'Total_PnL%': round(trades_df['PnL_%'].sum(), 2)
    }

# ---------------------------
# Run backtest
# ---------------------------
all_trades = []
for ticker in TICKERS:
    df = fetch_data(ticker)
    df = add_indicators(df)
    df.to_csv(f"{output_dir}/{ticker}_with_indicators.csv")
    trades = backtest_df(df, ticker)
    trades_df = pd.DataFrame(trades)
    trades_df.to_csv(f"{output_dir}/{ticker}_trades.csv", index=False)
    all_trades.append(trades_df)
    # Plot chart
    plt.figure(figsize=(10,5))
    plt.plot(df['Close'], label='Close')
    plt.plot(df[f'SMA_{SMA_SHORT}'], label=f'SMA{SMA_SHORT}')
    plt.plot(df[f'SMA_{SMA_LONG}'], label=f'SMA{SMA_LONG}')
    buy_dates = pd.to_datetime(trades_df['Entry_Date']) if not trades_df.empty else []
    if len(buy_dates) > 0:
        plt.scatter(buy_dates, df.loc[buy_dates]['Close'], marker='^', color='g', label='Buy', s=100)
    plt.title(f"{ticker} Signals")
    plt.legend()
    plt.savefig(f"{output_dir}/{ticker}_chart.png")
    plt.close()

# Combine and summarize
combined = pd.concat(all_trades, ignore_index=True) if all_trades else pd.DataFrame()
combined.to_csv(RESULTS_CSV, index=False)
print("\n=== Backtest Summary ===")
print(summarize_trades(combined))
print("\nSample Trades:\n", combined.head())



"""# **STEP 2**"""

!pip install gspread google-auth

from google.colab import files
uploaded = files.upload()  # Choose your downloaded JSON key file
service_account_file = list(uploaded.keys())[0]
print("Using key file:", service_account_file)

creds = Credentials.from_service_account_file(service_account_file, scopes=SCOPES)
gc = gspread.authorize(creds)

import gspread
from google.oauth2.service_account import Credentials
import pandas as pd
import os

# 1) Configure scopes
SCOPES = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

# 2) Authorize using the service account JSON you provided above
creds = Credentials.from_service_account_file(service_account_file, scopes=SCOPES)
gc = gspread.authorize(creds)

# 3) Settings: sheet name (update if you created a different name)
SHEET_NAME = "AlgoTradingLogs"   # name of the Google Sheet you created in Drive
# open sheet (by title). If you prefer, use open_by_key('<sheet-id>') with the id from URL
try:
    sh = gc.open(SHEET_NAME)
except gspread.SpreadsheetNotFound:
    # create spreadsheet in the service account's Drive (then share it with your personal account if needed)
    sh = gc.create(SHEET_NAME)
    print(f"Created sheet {SHEET_NAME}. You might want to share it with your main account to see it in Drive.")

# 4) Ensure tabs exist (TradeLog, PnL Summary, WinRatio)
def ensure_worksheet(title, rows=1000, cols=20):
    try:
        ws = sh.worksheet(title)
    except gspread.WorksheetNotFound:
        ws = sh.add_worksheet(title=title, rows=rows, cols=cols)
    return ws

trade_ws = ensure_worksheet("TradeLog")
summary_ws = ensure_worksheet("P&L Summary")
win_ws = ensure_worksheet("WinRatio")

# 5) Write helpers
def append_trades_to_sheet(trades_df: pd.DataFrame, worksheet=None):
    """
    trades_df: pandas DataFrame with columns like
    ['Ticker','Entry_Date','Entry_Price','Exit_Date','Exit_Price','PnL_%']
    """
    if trades_df is None or trades_df.empty:
        print("No trades to append.")
        return

    ws = worksheet or trade_ws

    # If sheet is empty, write header first
    existing = ws.get_all_values()
    start_row = 1
    if not existing:
        ws.append_row(list(trades_df.columns), value_input_option='USER_ENTERED')
        start_row = 2

    # Prepare rows as lists
    rows = trades_df.astype(str).values.tolist()
    # Append rows in batch (append_rows requires gspread > 5.0; fallback to append_row in loop)
    try:
        ws.append_rows(rows, value_input_option='USER_ENTERED')  # fast batch append
    except Exception:
        # fallback: append rows one-by-one
        for row in rows:
            ws.append_row(row, value_input_option='USER_ENTERED')
    print(f"Appended {len(rows)} trades to '{ws.title}'.")


def update_summary_to_sheet(summary_dict: dict, worksheet=None):
    """
    summary_dict example: {'Trades': 5, 'Win%': 60.0, 'Total_PnL%': 2.34}
    Writes a timestamped summary row.
    """
    ws = worksheet or summary_ws
    # ensure header
    existing = ws.get_all_values()
    headers = ["Run_Time"] + list(summary_dict.keys())
    if not existing:
        ws.append_row(headers, value_input_option='USER_ENTERED')
    # prepare values
    import datetime
    row = [datetime.datetime.now().isoformat()] + [summary_dict[k] for k in summary_dict.keys()]
    ws.append_row(row, value_input_option='USER_ENTERED')
    print(f"Appended summary to '{ws.title}'.")


def update_winratio_to_sheet(win_dict: dict, worksheet=None):
    """
    win_dict example: {'Win%': 60.0, 'Wins': 3, 'Losses': 2}
    """
    ws = worksheet or win_ws
    existing = ws.get_all_values()
    headers = ["Run_Time"] + list(win_dict.keys())
    if not existing:
        ws.append_row(headers, value_input_option='USER_ENTERED')
    import datetime
    row = [datetime.datetime.now().isoformat()] + [win_dict[k] for k in win_dict.keys()]
    ws.append_row(row, value_input_option='USER_ENTERED')
    print(f"Appended win ratio to '{ws.title}'.")

combined = pd.concat(all_trades, ignore_index=True, sort=False)
summary = summarize_trades(combined)

print(combined.head())
print(summary)

combined = pd.DataFrame([{
    'Ticker': 'TEST',
    'Entry_Date': '2024-08-01',
    'Entry_Price': 100,
    'Exit_Date': '2024-08-05',
    'Exit_Price': 110,
    'PnL_%': 10
}])
summary = {'n_trades': 1, 'n_wins': 1, 'win_rate_pct': 100, 'total_pnl_pct': 10, 'avg_pnl_pct': 10, 'max_drawdown_pct': 0}

append_trades_to_sheet(combined)
update_summary_to_sheet(summary)

# example: combined is your DataFrame of trades, summary is dict from summarize_trades()
append_trades_to_sheet(combined)                # writes the full trade log
update_summary_to_sheet(summary)                # write summary row
# Optionally compute win ratio dict:
win_dict = {'Win%': summary.get('Win%', None), 'Wins': summary.get('Wins', None), 'Trades': summary.get('Trades', None)}
update_winratio_to_sheet(win_dict)

from google.colab import files
uploaded = files.upload()  # Choose your .json service account key file
service_account_file = list(uploaded.keys())[0]
print("Using key file:", service_account_file)

import gspread
from google.oauth2.service_account import Credentials

# Set up API scopes
SCOPES = ["https://www.googleapis.com/auth/spreadsheets",
          "https://www.googleapis.com/auth/drive"]

# Authorize
creds = Credentials.from_service_account_file(service_account_file, scopes=SCOPES)
gc = gspread.authorize(creds)

# Open your Google Sheet (create if missing)
SHEET_NAME = "AlgoTradingLogs"  # Change if needed
try:
    sh = gc.open(SHEET_NAME)
except gspread.SpreadsheetNotFound:
    sh = gc.create(SHEET_NAME)
    print(f"Created sheet '{SHEET_NAME}', share it with your personal Google account.")

# Ensure worksheets exist
def ensure_worksheet(title, rows=1000, cols=20):
    try:
        ws = sh.worksheet(title)
    except gspread.WorksheetNotFound:
        ws = sh.add_worksheet(title=title, rows=rows, cols=cols)
    return ws

trade_ws = ensure_worksheet("TradeLog")
summary_ws = ensure_worksheet("P&L Summary")
win_ws = ensure_worksheet("WinRatio")

import pandas as pd
import datetime

def append_trades_to_sheet(trades_df, worksheet):
    if trades_df is None or trades_df.empty:
        print("No trades to append.")
        return
    if not worksheet.get_all_values():
        worksheet.append_row(list(trades_df.columns), value_input_option='USER_ENTERED')
    worksheet.append_rows(trades_df.astype(str).values.tolist(), value_input_option='USER_ENTERED')
    print(f"Appended {len(trades_df)} trades to '{worksheet.title}'.")

def update_summary_to_sheet(summary_dict, worksheet):
    if not worksheet.get_all_values():
        worksheet.append_row(["Run_Time"] + list(summary_dict.keys()), value_input_option='USER_ENTERED')
    row = [datetime.datetime.now().isoformat()] + list(summary_dict.values())
    worksheet.append_row(row, value_input_option='USER_ENTERED')
    print(f"Summary updated in '{worksheet.title}'.")

def update_winratio_to_sheet(summary_dict, worksheet):
    win_dict = {
        "Win%": summary_dict.get("win_rate_pct"),
        "Wins": summary_dict.get("n_wins"),
        "Trades": summary_dict.get("n_trades")
    }
    if not worksheet.get_all_values():
        worksheet.append_row(["Run_Time"] + list(win_dict.keys()), value_input_option='USER_ENTERED')
    row = [datetime.datetime.now().isoformat()] + list(win_dict.values())
    worksheet.append_row(row, value_input_option='USER_ENTERED')
    print(f"Win ratio updated in '{worksheet.title}'.")

combined = pd.concat(all_trades, ignore_index=True, sort=False)
summary = summarize_trades(combined)

append_trades_to_sheet(combined, trade_ws)
update_summary_to_sheet(summary, summary_ws)
update_winratio_to_sheet(summary, win_ws)

"""# **step 5**"""

